# tanya
Reverse task for newbies with antidebugging techniques. See [Releases](https://github.com/fuunyaka/tanya/releases) to get compiled program.

## Описание программы
Программа представляет собой виртуальную машину, работающую на перегрузках С++ классов, которая генерирует пользователю флаг. Цель задания заключается в том, чтобы пользователь научился разбираться в RTTI структурах С++.

## Алгоритм работы программы
Программа генерирует пользователю флаг в несколько раундов, путем сложения каждой последующей буквы с '0'.
Инструкции генерации i-того символа флага вставляются в общий пул инструкций виртуальной машины. 
На каждой итерации (в каждом раунде), массив инструкций виртуальной машины изменяется в зависимости от того, отлаживается ли программа, и правильно ли введена парольная фраза, результат проверки которой влияет на активацию верных инструкций и деактивацию мусорных инструкций антиотладки.
Парольная фраза считывается, хешируется алгоритмом `sha256` и проверяется на равенство эталонному хешу.

## Cредства антиотладки

### INT 2Dh + PUSH SS, POP SS
```asm
	push ss
	pop ss
	int 0x2d
	xor eax, eax
	add eax, 2
```
Процессор, выполняя последовательность `push ss, pop ss`, накладывает ограничение в невозможности вызвать какие-либо прерывания до окончания выполнения следующей после `pop ss` инструкции, что подразумевает невозможность сделать `single step` отладчиком и приводит к атоматическому выполнению следующей по счету инструкции `int 2Dh`. Это прерывание заставляет процессор использовать текущее значение `EIP`-регистра, как адресс исключения (`EXCEPTION_BREAKPOINT`) и увеличить его значение на 1. В итоге увеличение значения `EIP`-регистра, заставляет дебаггер пропустить один байт следующей интсрукции, что целиком сбивает поток исполнения.

### PREFIX REP INT1
```asm
	__asm __emit 0xF3 // 0xF3 0x64 disassembles as PREFIX REP:
	__asm __emit 0x64
	__asm __emit 0xF1 // One byte INT 1
```
Оппкод `0xF3 0x64` дизассемблируется, как префиксный вариант инструкции `REP`, за которым следует оппкод `0xF1`, дизассемблирующийся в `INT 1h` (устанавливает `hardware-breakpoint`, аналог `INT 3h`, который, однако не может быть автоматически снят дебаггером).

## Особенности решение задания
* При реверсе класса инструкции виртуальной машины можно заметить, что у всех инструкций есть поле булевое (назовем его `enabled`), которое при вызове перегрузки функции `execute` всегда проверяется на равенство истине. Поняв, какие инструкции портят вывод, можно их явно отключить через это поле.
* Если не отлаживать программу и понять, какую парольную фразу нужно ввести, программа автоматически сгенерирует верный флаг и выведет его.
* Обход проверки на равенство парольной фразы эталонной можно обойти следующими способами:
	* хеш для парольной фразы можно взломать (атака по словарю)
	* можно подобрать коллизию хеша
	* можно запатчить переменную, отвечающую за состояние проверки парольной фразы

## Сборка
Собирать проект стоит в конфигурации Debug/Release x86 с помощью Visual Studio (toolset v142).
> Компилятор Visual Studio не поддерживает ассемблерные вставки для конфигурации x64.

Для упрощения исследования программы рекомендуется выбрать пункты в меню проекта:
* С/C++ -> Оптимизация ->
	* Оптимизация = Отключено
	* Развертывание подставляемых функций = Отключено
	* Предпочитать размер или скорость = Предпочитать краткость кода
	* Оптимизация всей программы = Нет
* С/C++ -> Создание кода ->
	* Включить компановку на уровне функци = Нет